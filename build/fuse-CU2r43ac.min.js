function _(n){return Array.isArray?Array.isArray(n):Q(n)==="[object Array]"}const at=1/0;function lt(n){if(typeof n=="string")return n;let t=n+"";return t=="0"&&1/n==-at?"-0":t}function ut(n){return n==null?"":lt(n)}function L(n){return typeof n=="string"}function U(n){return typeof n=="number"}function dt(n){return n===!0||n===!1||gt(n)&&Q(n)=="[object Boolean]"}function G(n){return typeof n=="object"}function gt(n){return G(n)&&n!==null}function m(n){return n!=null}function P(n){return!n.trim().length}function Q(n){return n==null?n===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(n)}const ft="Incorrect 'index' type",pt=n=>`Invalid value for key ${n}`,mt=n=>`Pattern length exceeds max of ${n}.`,Mt=n=>`Missing ${n} property in key`,xt=n=>`Property 'weight' in key '${n}' must be a positive integer`,Y=Object.prototype.hasOwnProperty;class yt{constructor(t){this._keys=[],this._keyMap={};let e=0;t.forEach(s=>{let i=X(s);this._keys.push(i),this._keyMap[i.id]=i,e+=i.weight}),this._keys.forEach(s=>{s.weight/=e})}get(t){return this._keyMap[t]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}function X(n){let t=null,e=null,s=null,i=1,r=null;if(L(n)||_(n))s=n,t=Z(n),e=T(n);else{if(!Y.call(n,"name"))throw new Error(Mt("name"));const c=n.name;if(s=c,Y.call(n,"weight")&&(i=n.weight,i<=0))throw new Error(xt(c));t=Z(c),e=T(c),r=n.getFn}return{path:t,id:e,weight:i,src:s,getFn:r}}function Z(n){return _(n)?n:n.split(".")}function T(n){return _(n)?n.join("."):n}function Lt(n,t){let e=[],s=!1;const i=(r,c,o)=>{if(m(r))if(!c[o])e.push(r);else{let h=c[o];const a=r[h];if(!m(a))return;if(o===c.length-1&&(L(a)||U(a)||dt(a)))e.push(ut(a));else if(_(a)){s=!0;for(let l=0,d=a.length;l<d;l+=1)i(a[l],c,o+1)}else c.length&&i(a,c,o+1)}};return i(n,L(t)?t.split("."):t,0),s?e:e[0]}const kt={includeMatches:!1,findAllMatches:!1,minMatchCharLength:1},_t={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(n,t)=>n.score===t.score?n.idx<t.idx?-1:1:n.score<t.score?-1:1},vt={location:0,threshold:.6,distance:100},St={useExtendedSearch:!1,getFn:Lt,ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1};var u={..._t,...kt,...vt,...St};const At=/[^ ]+/g;function Ct(n=1,t=3){const e=new Map,s=Math.pow(10,t);return{get(i){const r=i.match(At).length;if(e.has(r))return e.get(r);const c=1/Math.pow(r,.5*n),o=parseFloat(Math.round(c*s)/s);return e.set(r,o),o},clear(){e.clear()}}}class z{constructor({getFn:t=u.getFn,fieldNormWeight:e=u.fieldNormWeight}={}){this.norm=Ct(e,3),this.getFn=t,this.isCreated=!1,this.setIndexRecords()}setSources(t=[]){this.docs=t}setIndexRecords(t=[]){this.records=t}setKeys(t=[]){this.keys=t,this._keysMap={},t.forEach((e,s)=>{this._keysMap[e.id]=s})}create(){this.isCreated||!this.docs.length||(this.isCreated=!0,L(this.docs[0])?this.docs.forEach((t,e)=>{this._addString(t,e)}):this.docs.forEach((t,e)=>{this._addObject(t,e)}),this.norm.clear())}add(t){const e=this.size();L(t)?this._addString(t,e):this._addObject(t,e)}removeAt(t){this.records.splice(t,1);for(let e=t,s=this.size();e<s;e+=1)this.records[e].i-=1}getValueForItemAtKeyId(t,e){return t[this._keysMap[e]]}size(){return this.records.length}_addString(t,e){if(!m(t)||P(t))return;let s={v:t,i:e,n:this.norm.get(t)};this.records.push(s)}_addObject(t,e){let s={i:e,$:{}};this.keys.forEach((i,r)=>{let c=i.getFn?i.getFn(t):this.getFn(t,i.path);if(m(c)){if(_(c)){let o=[];const h=[{nestedArrIndex:-1,value:c}];for(;h.length;){const{nestedArrIndex:a,value:l}=h.pop();if(m(l))if(L(l)&&!P(l)){let d={v:l,i:a,n:this.norm.get(l)};o.push(d)}else _(l)&&l.forEach((d,g)=>{h.push({nestedArrIndex:g,value:d})})}s.$[r]=o}else if(L(c)&&!P(c)){let o={v:c,n:this.norm.get(c)};s.$[r]=o}}}),this.records.push(s)}toJSON(){return{keys:this.keys,records:this.records}}}function tt(n,t,{getFn:e=u.getFn,fieldNormWeight:s=u.fieldNormWeight}={}){const i=new z({getFn:e,fieldNormWeight:s});return i.setKeys(n.map(X)),i.setSources(t),i.create(),i}function It(n,{getFn:t=u.getFn,fieldNormWeight:e=u.fieldNormWeight}={}){const{keys:s,records:i}=n,r=new z({getFn:t,fieldNormWeight:e});return r.setKeys(s),r.setIndexRecords(i),r}function R(n,{errors:t=0,currentLocation:e=0,expectedLocation:s=0,distance:i=u.distance,ignoreLocation:r=u.ignoreLocation}={}){const c=t/n.length;if(r)return c;const o=Math.abs(s-e);return i?c+o/i:o?1:c}function wt(n=[],t=u.minMatchCharLength){let e=[],s=-1,i=-1,r=0;for(let c=n.length;r<c;r+=1){let o=n[r];o&&s===-1?s=r:!o&&s!==-1&&(i=r-1,i-s+1>=t&&e.push([s,i]),s=-1)}return n[r-1]&&r-s>=t&&e.push([s,r-1]),e}const w=32;function $t(n,t,e,{location:s=u.location,distance:i=u.distance,threshold:r=u.threshold,findAllMatches:c=u.findAllMatches,minMatchCharLength:o=u.minMatchCharLength,includeMatches:h=u.includeMatches,ignoreLocation:a=u.ignoreLocation}={}){if(t.length>w)throw new Error(mt(w));const l=t.length,d=n.length,g=Math.max(0,Math.min(s,d));let f=r,p=g;const M=o>1||h,C=M?Array(d):[];let k;for(;(k=n.indexOf(t,p))>-1;){let x=R(t,{currentLocation:k,expectedLocation:g,distance:i,ignoreLocation:a});if(f=Math.min(x,f),p=k+l,M){let v=0;for(;v<l;)C[k+v]=1,v+=1}}p=-1;let $=[],I=1,b=l+d;const ht=1<<l-1;for(let x=0;x<l;x+=1){let v=0,S=b;for(;v<S;)R(t,{errors:x,currentLocation:g+S,expectedLocation:g,distance:i,ignoreLocation:a})<=f?v=S:b=S,S=Math.floor((b-v)/2+v);b=S;let V=Math.max(1,g-S+1),W=c?d:Math.min(g+S,d)+l,E=Array(W+2);E[W+1]=(1<<x)-1;for(let y=W;y>=V;y-=1){let F=y-1,B=e[n.charAt(F)];if(M&&(C[F]=+!!B),E[y]=(E[y+1]<<1|1)&B,x&&(E[y]|=($[y+1]|$[y])<<1|1|$[y+1]),E[y]&ht&&(I=R(t,{errors:x,currentLocation:F,expectedLocation:g,distance:i,ignoreLocation:a}),I<=f)){if(f=I,p=F,p<=g)break;V=Math.max(1,2*g-p)}}if(R(t,{errors:x+1,currentLocation:g,expectedLocation:g,distance:i,ignoreLocation:a})>f)break;$=E}const j={isMatch:p>=0,score:Math.max(.001,I)};if(M){const x=wt(C,o);x.length?h&&(j.indices=x):j.isMatch=!1}return j}function Et(n){let t={};for(let e=0,s=n.length;e<s;e+=1){const i=n.charAt(e);t[i]=(t[i]||0)|1<<s-e-1}return t}class et{constructor(t,{location:e=u.location,threshold:s=u.threshold,distance:i=u.distance,includeMatches:r=u.includeMatches,findAllMatches:c=u.findAllMatches,minMatchCharLength:o=u.minMatchCharLength,isCaseSensitive:h=u.isCaseSensitive,ignoreLocation:a=u.ignoreLocation}={}){if(this.options={location:e,threshold:s,distance:i,includeMatches:r,findAllMatches:c,minMatchCharLength:o,isCaseSensitive:h,ignoreLocation:a},this.pattern=h?t:t.toLowerCase(),this.chunks=[],!this.pattern.length)return;const l=(g,f)=>{this.chunks.push({pattern:g,alphabet:Et(g),startIndex:f})},d=this.pattern.length;if(d>w){let g=0;const f=d%w,p=d-f;for(;g<p;)l(this.pattern.substr(g,w),g),g+=w;if(f){const M=d-w;l(this.pattern.substr(M),M)}}else l(this.pattern,0)}searchIn(t){const{isCaseSensitive:e,includeMatches:s}=this.options;if(e||(t=t.toLowerCase()),this.pattern===t){let p={isMatch:!0,score:0};return s&&(p.indices=[[0,t.length-1]]),p}const{location:i,distance:r,threshold:c,findAllMatches:o,minMatchCharLength:h,ignoreLocation:a}=this.options;let l=[],d=0,g=!1;this.chunks.forEach(({pattern:p,alphabet:M,startIndex:C})=>{const{isMatch:k,score:$,indices:I}=$t(t,p,M,{location:i+C,distance:r,threshold:c,findAllMatches:o,minMatchCharLength:h,includeMatches:s,ignoreLocation:a});k&&(g=!0),d+=$,k&&I&&(l=[...l,...I])});let f={isMatch:g,score:g?d/this.chunks.length:1};return g&&s&&(f.indices=l),f}}class A{constructor(t){this.pattern=t}static isMultiMatch(t){return nt(t,this.multiRegex)}static isSingleMatch(t){return nt(t,this.singleRegex)}search(){}}function nt(n,t){const e=n.match(t);return e?e[1]:null}class Nt extends A{constructor(t){super(t)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(t){const e=t===this.pattern;return{isMatch:e,score:e?0:1,indices:[0,this.pattern.length-1]}}}class bt extends A{constructor(t){super(t)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(t){const e=t.indexOf(this.pattern)===-1;return{isMatch:e,score:e?0:1,indices:[0,t.length-1]}}}class Ft extends A{constructor(t){super(t)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(t){const e=t.startsWith(this.pattern);return{isMatch:e,score:e?0:1,indices:[0,this.pattern.length-1]}}}class Rt extends A{constructor(t){super(t)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(t){const e=!t.startsWith(this.pattern);return{isMatch:e,score:e?0:1,indices:[0,t.length-1]}}}class Ot extends A{constructor(t){super(t)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(t){const e=t.endsWith(this.pattern);return{isMatch:e,score:e?0:1,indices:[t.length-this.pattern.length,t.length-1]}}}class jt extends A{constructor(t){super(t)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(t){const e=!t.endsWith(this.pattern);return{isMatch:e,score:e?0:1,indices:[0,t.length-1]}}}class st extends A{constructor(t,{location:e=u.location,threshold:s=u.threshold,distance:i=u.distance,includeMatches:r=u.includeMatches,findAllMatches:c=u.findAllMatches,minMatchCharLength:o=u.minMatchCharLength,isCaseSensitive:h=u.isCaseSensitive,ignoreLocation:a=u.ignoreLocation}={}){super(t),this._bitapSearch=new et(t,{location:e,threshold:s,distance:i,includeMatches:r,findAllMatches:c,minMatchCharLength:o,isCaseSensitive:h,ignoreLocation:a})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(t){return this._bitapSearch.searchIn(t)}}class it extends A{constructor(t){super(t)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(t){let e=0,s;const i=[],r=this.pattern.length;for(;(s=t.indexOf(this.pattern,e))>-1;)e=s+r,i.push([s,e-1]);const c=!!i.length;return{isMatch:c,score:c?0:1,indices:i}}}const K=[Nt,it,Ft,Rt,jt,Ot,bt,st],rt=K.length,Wt=/ +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,Pt="|";function Tt(n,t={}){return n.split(Pt).map(e=>{let s=e.trim().split(Wt).filter(r=>r&&!!r.trim()),i=[];for(let r=0,c=s.length;r<c;r+=1){const o=s[r];let h=!1,a=-1;for(;!h&&++a<rt;){const l=K[a];let d=l.isMultiMatch(o);d&&(i.push(new l(d,t)),h=!0)}if(!h)for(a=-1;++a<rt;){const l=K[a];let d=l.isSingleMatch(o);if(d){i.push(new l(d,t));break}}}return i})}const zt=new Set([st.type,it.type]);class Kt{constructor(t,{isCaseSensitive:e=u.isCaseSensitive,includeMatches:s=u.includeMatches,minMatchCharLength:i=u.minMatchCharLength,ignoreLocation:r=u.ignoreLocation,findAllMatches:c=u.findAllMatches,location:o=u.location,threshold:h=u.threshold,distance:a=u.distance}={}){this.query=null,this.options={isCaseSensitive:e,includeMatches:s,minMatchCharLength:i,findAllMatches:c,ignoreLocation:r,location:o,threshold:h,distance:a},this.pattern=e?t:t.toLowerCase(),this.query=Tt(this.pattern,this.options)}static condition(t,e){return e.useExtendedSearch}searchIn(t){const e=this.query;if(!e)return{isMatch:!1,score:1};const{includeMatches:s,isCaseSensitive:i}=this.options;t=i?t:t.toLowerCase();let r=0,c=[],o=0;for(let h=0,a=e.length;h<a;h+=1){const l=e[h];c.length=0,r=0;for(let d=0,g=l.length;d<g;d+=1){const f=l[d],{isMatch:p,indices:M,score:C}=f.search(t);if(p){if(r+=1,o+=C,s){const k=f.constructor.type;zt.has(k)?c=[...c,...M]:c.push(M)}}else{o=0,r=0,c.length=0;break}}if(r){let d={isMatch:!0,score:o/r};return s&&(d.indices=c),d}}return{isMatch:!1,score:1}}}const D=[];function Dt(...n){D.push(...n)}function H(n,t){for(let e=0,s=D.length;e<s;e+=1){let i=D[e];if(i.condition(n,t))return new i(n,t)}return new et(n,t)}const O={AND:"$and",OR:"$or"},q={PATH:"$path",PATTERN:"$val"},J=n=>!!(n[O.AND]||n[O.OR]),Ht=n=>!!n[q.PATH],qt=n=>!_(n)&&G(n)&&!J(n),ct=n=>({[O.AND]:Object.keys(n).map(t=>({[t]:n[t]}))});function ot(n,t,{auto:e=!0}={}){const s=i=>{let r=Object.keys(i);const c=Ht(i);if(!c&&r.length>1&&!J(i))return s(ct(i));if(qt(i)){const h=c?i[q.PATH]:r[0],a=c?i[q.PATTERN]:i[h];if(!L(a))throw new Error(pt(h));const l={keyId:T(h),pattern:a};return e&&(l.searcher=H(a,t)),l}let o={children:[],operator:r[0]};return r.forEach(h=>{const a=i[h];_(a)&&a.forEach(l=>{o.children.push(s(l))})}),o};return J(n)||(n=ct(n)),s(n)}function Jt(n,{ignoreFieldNorm:t=u.ignoreFieldNorm}){n.forEach(e=>{let s=1;e.matches.forEach(({key:i,norm:r,score:c})=>{const o=i?i.weight:null;s*=Math.pow(c===0&&o?Number.EPSILON:c,(o||1)*(t?1:r))}),e.score=s})}function Vt(n,t){const e=n.matches;t.matches=[],m(e)&&e.forEach(s=>{if(!m(s.indices)||!s.indices.length)return;const{indices:i,value:r}=s;let c={indices:i,value:r};s.key&&(c.key=s.key.src),s.idx>-1&&(c.refIndex=s.idx),t.matches.push(c)})}function Bt(n,t){t.score=n.score}function Ut(n,t,{includeMatches:e=u.includeMatches,includeScore:s=u.includeScore}={}){const i=[];return e&&i.push(Vt),s&&i.push(Bt),n.map(r=>{const{idx:c}=r,o={item:t[c],refIndex:c};return i.length&&i.forEach(h=>{h(r,o)}),o})}class N{constructor(t,e={},s){this.options={...u,...e},this.options.useExtendedSearch,this._keyStore=new yt(this.options.keys),this.setCollection(t,s)}setCollection(t,e){if(this._docs=t,e&&!(e instanceof z))throw new Error(ft);this._myIndex=e||tt(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(t){m(t)&&(this._docs.push(t),this._myIndex.add(t))}remove(t=()=>!1){const e=[];for(let s=0,i=this._docs.length;s<i;s+=1){const r=this._docs[s];t(r,s)&&(this.removeAt(s),s-=1,i-=1,e.push(r))}return e}removeAt(t){this._docs.splice(t,1),this._myIndex.removeAt(t)}getIndex(){return this._myIndex}search(t,{limit:e=-1}={}){const{includeMatches:s,includeScore:i,shouldSort:r,sortFn:c,ignoreFieldNorm:o}=this.options;let h=L(t)?L(this._docs[0])?this._searchStringList(t):this._searchObjectList(t):this._searchLogical(t);return Jt(h,{ignoreFieldNorm:o}),r&&h.sort(c),U(e)&&e>-1&&(h=h.slice(0,e)),Ut(h,this._docs,{includeMatches:s,includeScore:i})}_searchStringList(t){const e=H(t,this.options),{records:s}=this._myIndex,i=[];return s.forEach(({v:r,i:c,n:o})=>{if(!m(r))return;const{isMatch:h,score:a,indices:l}=e.searchIn(r);h&&i.push({item:r,idx:c,matches:[{score:a,value:r,norm:o,indices:l}]})}),i}_searchLogical(t){const e=ot(t,this.options),s=(o,h,a)=>{if(!o.children){const{keyId:d,searcher:g}=o,f=this._findMatches({key:this._keyStore.get(d),value:this._myIndex.getValueForItemAtKeyId(h,d),searcher:g});return f&&f.length?[{idx:a,item:h,matches:f}]:[]}const l=[];for(let d=0,g=o.children.length;d<g;d+=1){const f=o.children[d],p=s(f,h,a);if(p.length)l.push(...p);else if(o.operator===O.AND)return[]}return l},i=this._myIndex.records,r={},c=[];return i.forEach(({$:o,i:h})=>{if(m(o)){let a=s(e,o,h);a.length&&(r[h]||(r[h]={idx:h,item:o,matches:[]},c.push(r[h])),a.forEach(({matches:l})=>{r[h].matches.push(...l)}))}}),c}_searchObjectList(t){const e=H(t,this.options),{keys:s,records:i}=this._myIndex,r=[];return i.forEach(({$:c,i:o})=>{if(!m(c))return;let h=[];s.forEach((a,l)=>{h.push(...this._findMatches({key:a,value:c[l],searcher:e}))}),h.length&&r.push({idx:o,item:c,matches:h})}),r}_findMatches({key:t,value:e,searcher:s}){if(!m(e))return[];let i=[];if(_(e))e.forEach(({v:r,i:c,n:o})=>{if(!m(r))return;const{isMatch:h,score:a,indices:l}=s.searchIn(r);h&&i.push({score:a,key:t,value:r,idx:c,norm:o,indices:l})});else{const{v:r,n:c}=e,{isMatch:o,score:h,indices:a}=s.searchIn(r);o&&i.push({score:h,key:t,value:r,norm:c,indices:a})}return i}}N.version="7.0.0",N.createIndex=tt,N.parseIndex=It,N.config=u,N.parseQuery=ot,Dt(Kt);export{N as F};
